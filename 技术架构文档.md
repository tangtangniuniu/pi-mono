# Pi Monorepo 技术架构文档

## 项目概述

Pi Monorepo 是一个用于构建AI代理和管理LLM部署的工具集。项目采用模块化设计，包含多个独立的包，每个包专注于特定的功能领域。

**项目特点：**
- 统一的多提供商LLM API
- 支持工具调用的状态化代理
- 交互式编码代理CLI
- Slack机器人集成
- 终端UI框架
- Web UI组件
- GPU Pod管理工具

## 整体架构设计

### 技术栈
- **语言**: TypeScript (ES Modules)
- **运行时**: Node.js ≥20.0.0
- **构建工具**: TypeScript编译器 + 自定义构建脚本
- **包管理**: npm workspaces (monorepo)
- **代码质量**: Biome (格式化、linting)
- **测试框架**: Vitest

### 架构模式
- **事件驱动架构**: 基于流式事件的消息传递
- **组件化设计**: 可插拔的扩展系统
- **分层架构**: 核心层、代理层、UI层分离
- **微内核架构**: 核心功能 + 可扩展插件

## 系统运行流程与核心业务逻辑

### 核心业务流程

1. **用户输入处理**
   - 接收用户消息（文本、图像）
   - 构建对话上下文
   - 调用LLM生成响应

2. **工具调用执行**
   - 解析LLM的工具调用请求
   - 执行相应的工具函数
   - 收集工具执行结果
   - 将结果返回给LLM

3. **流式响应处理**
   - 实时流式传输LLM响应
   - 处理思考内容、文本内容、工具调用
   - 更新UI状态

### 核心业务逻辑

```typescript
// 简化的核心流程
用户输入 → 构建上下文 → LLM调用 → 工具执行 → 响应生成
```

## 消息传递机制与数据流转路径

### 消息类型体系

#### 基础消息类型 (pi-ai)
- `UserMessage`: 用户输入消息
- `AssistantMessage`: AI助手响应消息
- `ToolResultMessage`: 工具执行结果消息

#### 代理消息类型 (pi-agent-core)
- `AgentMessage`: 扩展的消息类型，支持自定义消息类型
- 通过声明合并支持应用特定的消息类型

### 事件流系统

#### 消息生命周期事件
- `message_start`: 消息开始
- `message_update`: 消息更新（流式传输）
- `message_end`: 消息结束

#### 工具执行事件
- `tool_execution_start`: 工具执行开始
- `tool_execution_update`: 工具执行更新
- `tool_execution_end`: 工具执行结束

#### 代理生命周期事件
- `agent_start`: 代理开始处理
- `turn_start`: 新一轮处理开始
- `turn_end`: 当前轮次结束
- `agent_end`: 代理处理完成

### 数据流转路径

```
用户输入 → AgentMessage[] → transformContext() → AgentMessage[] → convertToLlm() → Message[] → LLM API
                                                                                    ↓
工具结果 ← ToolResultMessage[] ← 工具执行 ← 工具调用解析 ← LLM响应 ← 流式处理
```

## 各功能组件的结构、职责及交互关系

### 核心组件架构

```
┌─────────────────────────────────────────────────────────────┐
│                         应用层                                │
├─────────────────────────────────────────────────────────────┤
│  pi-coding-agent │    pi-mom     │    pi-web-ui    │ pi-pods │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                         代理层                                │
├─────────────────────────────────────────────────────────────┤
│                    pi-agent-core                             │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                         LLM层                                │
├─────────────────────────────────────────────────────────────┤
│                       pi-ai                                 │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                         UI层                                 │
├─────────────────────────────────────────────────────────────┤
│                    pi-tui                                   │
└─────────────────────────────────────────────────────────────┘
```

### 组件详细说明

#### 1. @mariozechner/pi-ai (LLM统一API层)
**职责**:
- 统一的多提供商LLM API接口
- 自动模型发现和提供商配置
- 令牌和成本跟踪
- 上下文持久化和跨模型会话传递

**核心特性**:
- 支持20+ LLM提供商
- 流式工具调用和部分JSON解析
- 图像输入和思考/推理支持
- 跨提供商会话传递

#### 2. @mariozechner/pi-agent-core (代理核心层)
**职责**:
- 状态化代理运行时
- 工具执行和事件流管理
- AgentMessage与LLM消息的转换

**核心特性**:
- 完整的代理生命周期管理
- 工具调用执行和状态跟踪
- 事件流系统用于UI更新
- 可插拔的消息转换系统

#### 3. @mariozechner/pi-coding-agent (编码代理CLI)
**职责**:
- 交互式终端编码代理
- 会话管理和分支功能
- 扩展系统和技能管理

**核心特性**:
- 四种运行模式：交互式、打印、RPC、SDK
- 强大的扩展系统（TypeScript扩展）
- 会话分支和压缩功能
- 自定义提示模板和主题

#### 4. @mariozechner/pi-tui (终端UI框架)
**职责**:
- 无闪烁的交互式CLI应用框架
- 差分渲染和同步输出
- 组件化UI系统

**核心特性**:
- 三策略差分渲染系统
- CSI 2026原子屏幕更新
- 内置组件库（编辑器、选择列表等）
- 主题支持和内联图像渲染

#### 5. @mariozechner/pi-mom (Slack机器人)
**职责**:
- 基于LLM的Slack机器人
- 自主工具安装和环境管理
- Docker沙箱支持

**核心特性**:
- 自管理设计（自动安装工具）
- 完整的bash访问权限
- 持久化工作空间
- 线程化详细输出

#### 6. @mariozechner/pi-web-ui (Web UI组件)
**职责**:
- 基于Web Components的AI聊天界面
- 工具执行和工件展示
- 存储和API密钥管理

**核心特性**:
- mini-lit Web组件
- Tailwind CSS v4样式
- IndexedDB存储后端
- CORS代理自动处理

#### 7. @mariozechner/pi-pods (GPU Pod管理)
**职责**:
- GPU Pod上的LLM部署管理
- 自动vLLM配置
- 多模型智能GPU分配

**核心特性**:
- 支持DataCrunch、RunPod等提供商
- 智能GPU分配算法
- OpenAI兼容API端点
- 交互式代理测试工具

### 组件交互关系

#### 数据流交互
1. **UI层 → 代理层**: 用户输入转换为AgentMessage
2. **代理层 → LLM层**: AgentMessage转换为LLM兼容的Message[]
3. **LLM层 → 工具层**: 解析工具调用并执行
4. **工具层 → 代理层**: 工具结果返回并转换为AgentMessage
5. **代理层 → UI层**: 通过事件流更新UI状态

#### 事件交互
- **同步事件**: 消息生命周期、工具执行状态
- **异步事件**: 流式响应、用户中断
- **状态事件**: 代理状态变更、会话更新

## 项目整体目录结构与模块划分

### 根目录结构
```
pi-mono/
├── packages/           # 所有功能包
│   ├── ai/            # LLM统一API
│   ├── agent/         # 代理核心
│   ├── coding-agent/  # 编码代理CLI
│   ├── mom/          # Slack机器人
│   ├── tui/          # 终端UI框架
│   ├── web-ui/       # Web UI组件
│   └── pods/         # GPU Pod管理
├── scripts/           # 构建和发布脚本
├── .github/          # GitHub工作流
└── 配置文件
```

### 模块依赖关系
```
pi-coding-agent → pi-agent-core → pi-ai
        ↓              ↓           ↓
pi-mom ──────────────┘           pi-tui
        ↓
pi-web-ui → pi-agent-core → pi-ai
```

### 构建系统
- **工作区管理**: npm workspaces
- **构建顺序**: tui → ai → agent → coding-agent → mom → web-ui → pods
- **版本同步**: 自动同步所有包的版本号
- **发布流程**: 统一的发布脚本

## 扩展系统和自定义能力

### 扩展类型
1. **工具扩展**: 注册LLM可调用的工具函数
2. **事件扩展**: 订阅代理生命周期事件
3. **UI扩展**: 自定义TUI组件和交互
4. **提供商扩展**: 添加新的LLM提供商

### 自定义能力
- **提示模板**: 可重用的对话模板
- **技能系统**: 工作流特定的CLI工具
- **主题系统**: 可定制的UI主题
- **包系统**: 通过npm分享扩展

## 安全性和最佳实践

### 安全特性
- **沙箱执行**: Docker容器隔离
- **API密钥管理**: 环境变量和加密存储
- **访问控制**: 基于权限的工具调用
- **输入验证**: TypeBox模式验证

### 开发最佳实践
- **类型安全**: 完整的TypeScript类型定义
- **测试覆盖**: 单元测试和集成测试
- **文档完整性**: 详细的API文档和示例
- **错误处理**: 健壮的错误处理和恢复机制

## 部署和运维

### 部署选项
1. **CLI工具**: 全局安装的编码代理
2. **Slack集成**: 自托管的Slack机器人
3. **Web应用**: 基于Web组件的聊天界面
4. **GPU服务**: 云GPU Pod上的LLM服务

### 监控和日志
- **结构化日志**: 详细的执行日志
- **性能监控**: 令牌使用和成本跟踪
- **错误报告**: 自动错误收集和报告

---

*本文档基于项目代码分析和README文档整理，反映了项目的当前架构状态。*